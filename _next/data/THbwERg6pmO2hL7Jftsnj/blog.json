{"pageProps":{"posts":[{"content":"\n# GithubPage 建立個人頁\n\n關於部落格\n","data":{"title":"關於部落格","description":"關於部落格","tags":["Github"],"publishedDate":"2021-10-17"},"filePath":"about-blog.mdx"},{"content":"\n# 單元測試\n\n關於 BDD 單元測試\n","data":{"title":"BDD單元測試","description":"BDD單元測試","tags":["BDD"],"publishedDate":"2021-10-18"},"filePath":"bdd-first.mdx"},{"content":"\nThis is an example post, with a [link](https://nextjs.org) and a React\ncomponent:\n\n```jsx\n(function someDemo() {\n  var test = 'Hello World!';\n  console.log(test);\n})();\n```\n\nThe title and description are pulled from the MDX file and processed using\n`gray-matter`. Additionally, links are rendered using a custom component passed\nto `next-mdx-remote`.\n\n<Button />\n","data":{"title":"Example Post","description":"This frontmatter description will appear below the title","tags":["React","Next"],"publishedDate":"2021-05-14"},"filePath":"example-posts.mdx"},{"content":"\n## 前言\n\nuseState 的基本用法\n\n```javascript\nconst [state, setState] = useState(init);\n```\n\n例子\n\n```javascript\nfunction Counter() {\n  const [count, setCount] = React.useState(() => 0);\n  const increment = () => setCount(previousCount => previousCount + 1);\n  return <button onClick={increment}>{count}</button>;\n}\n```\n\n## 惰性初始化函数\n\n一般寫法\n\n```javascript\nconst initialState = Number(window.localStorage.getItem('count'));\nconst [count, setCount] = React.useState(initialState);\n```\n\n當函數組件更新 re-render 時，函數組件內所有代碼都會重新執行一遍。此時\ninitialState 的初始值是一個相對開銷較大的 IO 操作。每次函數組件 re-render 時，第\n一行代碼都會被執行一次，引起不必要的性能損耗。\n\n惰性初始\n\n```javascript\nconst initialState = () => Number(window.localStorage.getItem('count'));\nconst [count, setCount] = React.useState(initialState);\n```\n\n當 initialState 以函數形式傳入時，它只會在函數組件初始化的時候執行一次，函數\nre-render 時不會再被執行。這個函數即惰性初始化函數這個特性，可以在這種場景下規避\n不必要的性能問題。\n\n## 更新函数\n\n例子\n\n```javascript\nfunction DelayedCounter() {\n  const [count, setCount] = React.useState(0);\n  const increment = async () => {\n    await doSomethingAsync();\n    setCount(count + 1);\n  };\n  return <button onClick={increment}>{count}</button>;\n}\n```\n\n上面的方法假設連續點擊三次，conunt 的值一直都是 1，而不是預期的數值 3。\n\n例子 2\n\n```javascript\nfunction DelayedCounter() {\n  const [count, setCount] = React.useState(0);\n  const increment = async () => {\n    await doSomethingAsync();\n    setCount(previousCount => previousCount + 1);\n  };\n  return <button onClick={increment}>{count}</button>;\n}\n```\n\n可以改用例子 2 的寫法，用傳函式的方法，setCount 會隱式傳入前一次的數值，所以每次\n點擊都會帶入更新後的數值。\n\n## 結論\n\n- 惰性初始化函數在某些場景下可以規避額外的計算開銷，提升性能\n","data":{"title":"useState惰性初始化函數和更新函數","description":"useState惰性初始化函數和更新函數","tags":["HOOK"],"publishedDate":"2021-10-25"},"filePath":"hook-use-state.mdx"},{"content":"\n### 微前端的出现的背景和意义\n\n微前端是什么：微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成\n整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用\n，而在用户看来仍然是内聚的单个产品。\n\n微前端诞生在两个大的背景下，在提倡拥抱变化的前端社区可以看到新的框架、技术、概念\n层出不穷，并且随着 Web 标准的演进，前端应用已经具备更好的性能、更快的开发效率。\n但随着而来的是应用的复杂程度更高、涉及的团队规模更广、更高的性能要求，应用复杂度\n已经成为阻塞业务发展的重要瓶颈。\n\n微前端就是诞生于 Web 应用日益复杂化的场景中，因为随着网络速度、计算机硬件水平的\n提升和 Web 标准的演进，过去 Web 应用用户体验远不如传统的应用软件时代已逐渐远去，\n两者之间在用户体验上的差距不断缩减，并且由于 Web 应用开发速度快、用完即走等特性\n，导致的一个最终结果就是「能用 Web 技术实现的应用，最终都会通过 Web 来实现」。在\n近几年涌现了一大批之前只能在传统 PC 软件中才能看到的优秀产品，例如\n：Photoshop、Web Office、Web IDE。尽管随着 Web 标准的演进，前端工程化也在不断演\n变，从模块化到组件化在到现在的工程化，但在面对跨团队大规模开发、跨团队企业级应用\n协作，现有的分治设计模式仍然显得有心无力。\n\n### 大规模 Web 应用的困局\n\n尽管 Web 应用的复杂度和参与人数以爆炸式的增长速度，但却没有一种新的架构模式来解\n决现有的困境，并同时兼顾 DX（developer experience）和 UX（user experience）。\n\n以字节跳动内「研发中台」举例，在研发日常工作中需要使用非常多的研发系统，例如：代\n码管理、代码构建、域名管理、应用发布、CDN 资源管理、对象存储等。站在整个公司研发\n的角度考虑，最好的产品形态就是将所有的研发系统都放置同一个产品内，用户是无法感知\n他在使用不同的产品，对于用户而言就是单个产品不存割裂感，也不需要去学习多个平台，\n仅仅需要学习和了解字节跳动内的「研发中台」即可。\n\n文章出處 [關於微前端](https://juejin.cn/post/7016911648656982024)\n\n<Button />\n","data":{"title":"關於微前端","description":"微前端的出现的背景和意义","tags":["React"],"publishedDate":"2021-10-19"},"filePath":"micro-frontend.mdx"},{"content":"\n# RxJS 与 函数式编程 - RxJS 入门\n\n## 前言\n\n这是一个新的系列，记录自己学习 RxJS 以及函数式编程的过程。这个系列的目的一个是作\n为笔记记录，另一个是希望看到这个系列的你能对 RxJS 和函数式编程提起兴趣学习/使用\n起来。\n\n学习 RxJS 不是因为他是一个多么新的技术（它已经存在多年）也不是因为他是多炫酷的技\n术，学习它是因为它确实能帮我们解决许多问题：\n\n- 如何控制大量代码的复杂度\n- 如何保持代码的可读性\n- 如何处理异步操作\n\n可能有许多人早已听说过 RxJS 以及它令人望而生畏的学习曲线（别跑说你呢），别怕这个\n系列会以最易懂的方式解释给你（复杂的我也不会）。借用 RxJS 入门手册中的一句话：\n\n> 可以把 RxJS 当做是用来处理事件的 [Lodash](https://lodash.com/) 。\n\n如果没有特殊说明，这个系列的 RxJS 版本都是 6.6.3。系列内容基于程墨的《深入浅出\nRxJS》（好书推荐），并做了一定更新与总结，可能会引用书中原话。\n\n## 概念介绍\n\n在 RxJS 中用来解决异步事件管理的的基本概念是：\n\n- **Observable (可观察对象)**: 表示一个概念，这个概念是一个可调用的未来值或事件\n  的集合。\n- **Observer (观察者)**: 一个回调函数的集合，它知道如何去监听由 Observable 提供\n  的值。\n- **Subscription (订阅)**: 表示 Observable 的执行，主要用于取消 Observable 的执\n  行。\n- **Operators (操作符)**: 采用函数式编程风格的纯函数 (pure function)，使用像\n  map、filter、concat、flatMap 等这样的操作符来处理集合。\n- **Subject (主体)**: 相当于 EventEmitter，并且是将值或事件多路推送给多个\n  Observer 的唯一方式。\n- **Schedulers (调度器)**: 用来控制并发并且是中央集权的调度员，允许我们在发生计\n  算时进行协调，例如 setTimeout 或 requestAnimationFrame 或其他。\n\n### Observable 和 Observer\n\n学习 RxJS 绝对避不开的概念就是 Observable 和 Observer。\n\n> 可以说 RxJS 的运行就是 Observable 和 Observer 之间的互动游戏。\n\n顾名思义，Observable 就是 “可被观察的东西”，你可以把它理解为数据源，Observer 是\n“观察者”，可以理解为对数据源进行操作的角色。二者通过 Observable 对象的 subscribe\n函数连接。\n\n#### 第一个 Observable\n\n我们来看一个简单的 Observable：\n\n```javascript\nimport {Observable} from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.next(2);\n  observer.next(3);\n});\n\nconst observer = {\n  next: x => console.log('got value ' + x),\n};\n\nobservable.subscribe(observer);\n```\n\n> 你可以打开\n> [codesandbox](https://codesandbox.io/s/floral-framework-ui861?file=/src/index.js)\n> 直接查看结果\n\n这段代码依次输出：\n\n```\ngot value 1\ngot value 2\ngot value 3\n```\n\n这是一个典型的观察者模式实现，`observable` 直接由 RxJS 的 **Observable** 实例化\n得来，而在他的回调参数里面连续调用三次 next 输出了 3 个值；下面 `observer` 定义\n了一个含有 next 函数的对象，next 函数只是 log 了输入值，很明显这里的 next 函数正\n是上方 `observable` 回调中连续调用三次的 next；最后，由 `observable` 的\n`subscribe` 方法连接起 `observable` 与 `observer`。\n\n只是为了输出几个数，写了一长串代码似乎有些本末倒置，下面就用 RxJS 解决一些复杂的\n问题。\n\n#### Observable 的 complete\n\n```javascript\nimport {Observable} from 'rxjs';\n\nconst observable = new Observable(observer => {\n  let num = 1;\n  const handle = setInterval(() => {\n    observer.next(num++);\n\n    if (num > 10) {\n      clearInterval(handle);\n    }\n  }, 1000);\n});\n\nconst observer = {\n  next: x => console.log('got value ' + x),\n};\n\nobservable.subscribe(observer);\n```\n\n> 你可以打开\n> [codesandbox](https://codesandbox.io/s/hidden-dew-ifhjp?file=/src/index.js) 直\n> 接查看结果\n\n上面代码将之前的三个 next 调用改为利用 `setInterval` 每隔一秒递增 num，并且当\nnum 大于 10 的时候取消掉 `setInterval`。\n\n看到这里不知道大家有没有注意两个点：\n\n1. Observable 推送数据可以存在时间间隔，这意味着它可以处理异步操作。\n1. Observable 虽然在 num 大于 10 的时候停止了推送数据，但是它本身并不知道会不会\n   有新数据产生，这意味着 Observable 仍在工作。\n\n为了通知 Observable 停止工作，需要对上面的代码进行一些完善：\n\n```javascript\nimport {Observable} from 'rxjs';\n\nconst observable = new Observable(observer => {\n  let num = 1;\n  const handle = setInterval(() => {\n    observer.next(num++);\n\n    if (num > 10) {\n      clearInterval(handle);\n      observer.complete();\n    }\n  }, 1000);\n});\n\nconst observer = {\n  next: x => console.log('got value ' + x),\n  complete: () => console.log('complete'),\n};\n\nobservable.subscribe(observer);\n```\n\n> 你可以打开\n> [codesandbox](https://codesandbox.io/s/beautiful-leaf-8nyji?file=/src/index.js)\n> 直接查看结果\n\n你可以看到我们修改了两个地方:\n\n- 为 `observer` 对象增加了一个 complete 函数，这个函数描述 Observable 结束时做的\n  事情。\n- 为 `observable` 的回调取消 `setInterval` 后调用 complete 函数，告知 Observable\n  应该如何结束。\n\n#### Observable 的 error\n\n健壮的代码除了 next 与 complete 表示逻辑，非常需要对错误的处理。拿代码举个栗子：\n\n```javascript\nimport {Observable} from 'rxjs';\n\nconst observable = new Observable(observer => {\n  observer.next(1);\n  observer.error('something wrong');\n  observer.complete();\n});\n\nconst observer = {\n  next: x => console.log('got value ' + x),\n  error: err => console.log('something seems to be wrong: ' + err),\n  complete: () => console.log('complete'),\n};\n\nobservable.subscribe(observer);\n```\n\n> 你可以打开\n> [codesandbox](https://codesandbox.io/s/fancy-darkness-50hjz?file=/src/index.js)\n> 直接查看结果\n\n执行结果：\n\n```\ngot value 1\nsomething seems to be wrong: something wrong\n```\n\n看代码注意到了调用 `observer.error` 后紧跟着调用了 `observer.complete`，但是结果\n却没有输出 complete，这是为什么？\n\n> 在 RxJS 中，一个 Observable 对象只有一种终结状态，要么是完结（complete），要么\n> 是出错（error）。一旦进入完结状态，不论是 error 还是 complete 都将不再调用\n> observer 的其他函数。\n\n#### 退订 Observable\n\n有合就有分，我们已经了解了 Observable 和 Observer 如何建立关系了，是时候知道怎么\n分开它们了。\n\n```javascript\nimport {Observable} from 'rxjs';\n\nconst observable = new Observable(observer => {\n  let num = 1;\n  const handle = setInterval(() => {\n    observer.next(num++);\n\n    if (num > 10) {\n      clearInterval(handle);\n      observer.complete();\n    }\n  }, 1000);\n\n  return {\n    unsubscribe: () => {\n      console.log('unsubscribe');\n    },\n  };\n});\n\nconst observer = {\n  next: x => console.log('got value ' + x),\n  error: err => console.log('something seems to be wrong: ' + err),\n  complete: () => console.log('complete'),\n};\n\nconst subscription = observable.subscribe(observer);\nsetTimeout(() => {\n  subscription.unsubscribe();\n}, 3500);\n```\n\n> 你可以打开\n> [codesandbox](https://codesandbox.io/s/wonderful-resonance-ds6op?file=/src/index.js)\n> 直接查看结果\n\n看这段代码，我们将 subscribe 的返回结果赋值给变量 `subscription`，并且在完成订阅\n3.5 秒后调用 `subscription.unsubscribe`，也就是订阅完成后 3.5 秒退订。\n\n运行后输出：\n\n```\ngot value 1\ngot value 2\ngot value 3\nunsubscribe\n```\n\n如果不进行主动退订，上面的代码应该会输出到 10 并且调用 complete 后结束。主动退订\n后，我们看到只输出到 3 并且没有调用 complete，也就是在 complete 之前就断开了连接\n。\n\n> 这是 RxJS 中很重要的一点：Observable 产生的事件，只有 Observer 通过 subscribe\n> 订阅之后才会收到，在 unsubscribe 之后就不会再收到。\n\n其实读到这里我产生过一个疑问，想要停止代码运行应该调用 complete 还是\nunsubscribe？我进行了一个实验：\n\n```javascript\nimport {Observable} from 'rxjs';\n\nconst observable = new Observable(observer => {\n  let num = 1;\n  const handle = setInterval(() => {\n    observer.next(num++);\n\n    if (num > 10) {\n      clearInterval(handle);\n      observer.complete();\n    }\n  }, 1000);\n\n  return {\n    unsubscribe: () => {\n      console.log('unsubscribe');\n    },\n  };\n});\n\nconst observer = {\n  next: x => console.log('got value ' + x),\n  error: err => console.log('something seems to be wrong: ' + err),\n  complete: () => console.log('complete'),\n};\n\nconst subscription = observable.subscribe(observer);\n// setTimeout(() => {\n//   subscription.unsubscribe();\n// }, 3500);\n```\n\n首先我注释掉主动断开连接的部分，让程序通过 complete 调用结束，输出结果：\n\n```\ngot value 1\ngot value 2\ngot value 3\ngot value 4\ngot value 5\ngot value 6\ngot value 7\ngot value 8\ngot value 9\ngot value 10\ncomplete\nunsubscribe\n```\n\n可以看到 complete 后仍然调用了 unsubscribe，那么把 `observer.complete` 换成\n`observer.error` 呢？感兴趣的可以去试一下，这里直接说我得到的结论吧：\n\n> 每个 Observable 仅会被退订一次，complete 和 error 这两个代表结束的函数调用后紧\n> 接会着调用 unsubscribe。另一种情况，如果在 complete 或 error 前主动进行\n> `subscription.unsubscribe` 退订，那么 complete 或 error 都不会执行并且退订。\n\n## 结语\n\n这一篇文章介绍了 Observable 和 Observer 这两大 RxJS 的主角，二者通过 Observable\n对象的 subscribe 函数连接，让 Observer 对象订阅 Observable 对象推送的内容，并且\n可以通过 unsubscribe 退订。\n\n下一篇讲一下 RxJS 的操作符。\n\n<Button />\n","data":{"title":"RXJS","description":"RxJS》（好书推荐），并做了一定更新与总结，可能会引用书中原话。","tags":["RXjs"],"publishedDate":"2021-10-17"},"filePath":"rxjs.mdx"},{"content":"\n### 前言\n\n團隊往往在接到新需求時，由 PM 製作規格書，RD 透過規格文件實作開發，但大部分都有\n所謂認知落差，陷入到知識的詛咒困境，下面這張圖可以表示軟體需求到開發的認知落差\n![ses](/images/specification-image.png)\n\n### 溝通方式\n\n課程中，講師請小組舉例出常用的溝通方式\n\n- 文件\n- 語音\n- 面對面\n- 會議\n\n接下來開始玩一個遊戲，整個大團隊分成兩組，一組是 PM 撰寫規格組，一組為 RD 開發組\n，這邊其實是由 PM&RD 角色互換，透過一張風景畫，由 RD 撰寫規格書，只能用文字，禁\n止交談討論，也不能用圖片，最後讓 PM 去透過規則書描述去畫出一幅畫，過程對需求有疑\n問只能透過真人 mail 助手傳遞訊息，原來對自己的開出規則有信心，認為自己應該已經涵\n蓋整個情境，結果最後畫出的畫還是有不小落差 XD。\n\n### Specification by Example（SBE）\n\n面對面溝通是有技巧的，『案例具體』用來消除知識的詛咒，減少專有名詞或將專有名詞案\n例化，用大家都瞭解的用語，以一致性的用字來撰寫案例。實例化需求的重點\n\n- 前提是數據\n- 關鍵行為\n- 實作 / 操作細節要抽象\n\n對團隊而言，需求中重要的部分寫明，大家一起討論達成「共識」，大家一同完成 SBE，透\n過不斷的練習來達到產品的探索，以及提升大家對產品領域知識，RD 透過實例化情境去開\n發，QA 透過實例化案例驗收，PM 以實例化去撰寫規格。\n\n### Gherkin 描述語法 (feature)\n\n- 能描寫明確可執行的 specification，讓 Cucumber 能看懂，同時具備人類語意可讀性\n- 能透過 Cucumber 進行自動化測試 [cucumber.io](https://cucumber.io/)\n- 能文件化系統的實際行為(actually behaves)\n\n```bash\n   Give 用戶帳號test_mayo@mayohr.com\n   And  密碼1@dji123\n   When 使用test_mayo進行登入\n   Then 登入成功\n   And  顯示XE首頁\n```\n\n### 寫在最後\n\n我認為課程最重要的目的，就是透過實例化需求達成共識，很大程度減少認知落差，避免陷\n入知識的詛咒，讓大家對產品開發有一致的方向，另外也會透過產品的探索，開發人員除了\n注重軟體工程化，同時也一步步提升商業思維，提高產品的品質與價值。\n\n<Button />\n","data":{"title":"實例化需求","description":"團隊往往在接到新需求時，由 PM 製作規格書，RD 透過規格文件實作開發，但大部分都有所謂認知落差","tags":["Test"],"publishedDate":"2021-10-21"},"filePath":"specification-by-example.mdx"},{"content":"\n# 單元測試\n\n關於 TDD 單元測試\n","data":{"title":"TDD單元測試","description":"TDD單元測試","tags":["TDD"],"publishedDate":"2021-10-15"},"filePath":"tdd-first.mdx"}],"tags":["Github","BDD","React","Next","HOOK","RXjs","Test","TDD"]},"__N_SSG":true}